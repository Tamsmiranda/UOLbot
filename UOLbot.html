<HTML>
<HEAD>
<TITLE>UOLbot</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#nome">NOME</A></LI>
	<LI><A HREF="#plataformas suportados">PLATAFORMAS SUPORTADOS</A></LI>
	<LI><A HREF="#resumo">RESUMO</A></LI>
	<LI><A HREF="#descrição">DESCRIÇÃO</A></LI>
	<LI><A HREF="#introdução">INTRODUÇÃO</A></LI>
	<LI><A HREF="#métodos">MÉTODOS</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#referências">REFERÊNCIAS</A></LI>
	<LI><A HREF="#versão">VERSÃO</A></LI>
	<LI><A HREF="#histórico">HISTÓRICO</A></LI>
	<LI><A HREF="#copyright">COPYRIGHT</A></LI>
	<LI><A HREF="#autor">AUTOR</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="nome">NOME</A></H1>
<P>UOLbot - Bot para bate-papo da UOL</P>
<P>
<HR>
<H1><A NAME="plataformas suportados">PLATAFORMAS SUPORTADOS</A></H1>
<P>Teoricamente, <STRONG>todos</STRONG> onde roda o <EM>perl</EM>. Oficialmente, foi testado em:</P>
<UL>
<LI>
Linux
(perl 5.6.1)
<P></P>
<LI>
Windows
(ActivePerl 5.6.1 Build 630)
<P></P></UL>
<P>
<HR>
<H1><A NAME="resumo">RESUMO</A></H1>
<PRE>
  #!/usr/bin/perl
  use UOLbot;</PRE>
<PRE>
  my $bot = new UOLbot (Nick =&gt; 'b0t');</PRE>
<PRE>
  $bot-&gt;login ('<A HREF="http://batepapo4.uol.com.br:3999">http://batepapo4.uol.com.br:3999</A>');
  $bot-&gt;send (&quot;oi!&quot;);
  $bot-&gt;logout;</PRE>
<PRE>
  exit;</PRE>
<P>
<HR>
<H1><A NAME="descrição">DESCRIÇÃO</A></H1>
<P>O <CODE>UOLbot</CODE> é uma classe que implementa interface para webchat da UOL
(http://www.uol.com.br/). Ele é uma solução prática para entrar na sala
de bate-papo, enviar mensagem para todo mundo e sair. Onde tal
habilidade se aplica com sucesso? Propaganda. Sim, spam é muito mau,
mas -- <STRONG>rende $$$</STRONG>.</P>
<P>Você que está prestes a se juntar à liga dos spammers, não precisa
de muitos requisitos para usar esse módulo. Só o <EM>perl</EM> e o <EM>LWP</EM>.
Fiz de tudo para deixar o módulo mais simples possível; todas as
``partes móveis'' estão encapsuladas dentro de uma atraente interface
Orientada a Objetos. Não se assuste ao abrir o código do módulo, esse
é o meu primeiro programa funcional usando Orientação a Objetos,
portanto <STRONG>por dentro</STRONG> ainda é uma mistura bizarra de programação
linear com OOP.</P>
<P><EM>Obs</EM>: antes que me pergunte, ``eu estou lendo em português aqui,
então por que <A HREF="#item_send"><CODE>send</CODE></A> e não <EM>enviar</EM>, ou <A HREF="#item_logout"><CODE>logout</CODE></A> ao invés de <EM>sair</EM>?''
A razão é simples: o ``resto'' do <EM>perl</EM> está em inglês, certo?
Por mim, fica estranho ler e entender o que faz algo como</P>
<PRE>
  next if $bot-&gt;enviar and not scalar $bot-&gt;usuarios;</PRE>
<P>
<HR>
<H1><A NAME="introdução">INTRODUÇÃO</A></H1>
<P>Agora, o princípio ativo. Antes de tudo, você deve criar uma instância
do bot:</P>
<PRE>
  my $bot = new UOLbot (Nick =&gt; 'b0t');</PRE>
<P>O parâmetro <EM>Nick</EM> especifica o nickname do bot.
Você pode passar outros, que serão descritos posteriormente.
Você também pode <STRONG>não</STRONG> passar nenhum, aí o seu bot será um
discreto ``unnamed''.
Você pode ter várias instâncias, só não sei qual o sentido
disso.</P>
<P>Pronto, você criou o seu bot... E agora? Ele deve entrar numa sala, né?</P>
<PRE>
  $bot-&gt;login ('<A HREF="http://batepapo4.uol.com.br:3999">http://batepapo4.uol.com.br:3999</A>');</PRE>
<P>(ótima sala para propaganda, eheheh)
Aí você passa a URL da sala. É o único parâmetro <STRONG>necessário</STRONG>.
É claro que ter que saber essa URL é um pé no saco, você pode entrar na
sala só sabendo o seu nome. Mas isso é para depois.</P>
<P>Estando na sala, o que fazer? Falar!</P>
<PRE>
  $bot-&gt;send (&quot;oi!&quot;);</PRE>
<P>``Oi mundo'' <CODE>:P</CODE>
Sem comentários aqui.</P>
<P>Quando você ``falou'' tudo o que quis, tchau para todos!</P>
<PRE>
  $bot-&gt;logout;</PRE>
<P>Isso é o básico. Se não entendeu, pare por aqui.</P>
<P>
<HR>
<H1><A NAME="métodos">MÉTODOS</A></H1>
<P>Os métodos do <CODE>UOLbot</CODE> são:</P>
<DL>
<DT><STRONG><A NAME="item_new"><CODE>new ([ARGS])</CODE></A></STRONG><BR>
<DD>
Construtor para o bot. Retorna a referência para objeto <CODE>UOLbot</CODE>.
Argumentos <CODE>ARGS</CODE> devem ser passados em forma:
<PRE>
  new (Chave1 =&gt; 'valor1',
       Chave2 =&gt; 2);</PRE>
<P>Note que os argumentos especificados aqui são <EM>imutáveis</EM>
depois da instância ser criada, isto é,
há métodos para <EM>ler</EM> o seu conteúdo mas não <EM>gravar</EM>!
Argumentos válidos (<STRONG>todos</STRONG> opcionais):</P>
<DL>
<DT><STRONG><A NAME="item_UA"><EM>UA</EM></A></STRONG><BR>
<DD>
referência para objeto LWP::UserAgent externo (é criada instância interna por default)
<P></P>
<DT><STRONG><A NAME="item_Nick"><EM>Nick</EM></A></STRONG><BR>
<DD>
o nickname (valor default é <EM>``unnamed''</EM>)
<P></P>
<DT><STRONG><A NAME="item_Color"><EM>Color</EM></A></STRONG><BR>
<DD>
a cor do nickname (valor default é <EM>0</EM>)
<P><EM>Obs</EM>: valores possíveis são:</P>
<PRE>
  0 - Preto
  1 - Vermelho
  2 - Verde
  3 - Azul
  4 - Laranja
  5 - Cinza
  6 - Roxo</PRE>
<P></P>
<DT><STRONG><A NAME="item_Listen_Handler"><EM>Listen_Handler</EM></A></STRONG><BR>
<DD>
referência para o código que vai processar as
informações recebidas da sala (indefinido por default).
Por exemplo:
<PRE>
  Listen_Handler =&gt; sub { print $_[0] }</PRE>
<P>imprime qualquer coisa recebida e</P>
<PRE>
  Listen_Handler =&gt; \&amp;listen_handler
  ...
  sub listen_handler {
     my $data = shift;
     ...
     return;
  }</PRE>
<P>define a sub-rotina <EM>listen_handler</EM> como handler de 'escuta'.
Nesse caso, variável <EM>$data</EM> recebe pacotes com código HTML recebidos.</P>
<P><EM>Obs</EM>: lembre que nem sempre há uma mensagem em um pacote. O servidor
(ou buffer do sistema operacional) pode juntar vários pacotes num só.</P>
<P></P></DL>
<DT><STRONG><A NAME="item_ua"><CODE>ua</CODE></A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_nick"><CODE>nick</CODE></A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_color"><CODE>color</CODE></A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_listen_handler"><CODE>listen_handler</CODE></A></STRONG><BR>
<DD>
Métodos para ler/definir os parâmetros definidos pelo <A HREF="#item_new"><CODE>new</CODE></A>.
<P><EM>Obs</EM>: Você pode ler os valores a qualquer momento, mas só poderá
definir quando a instância <EM>não estiver logada</EM> com <A HREF="#item_login"><CODE>login</CODE></A>!</P>
<P></P>
<DT><STRONG><A NAME="item_list_subgrp"><CODE>list_subgrp (SUBGRP)</CODE></A></STRONG><BR>
<DD>
Enumera as salas de bate-papo de um sub-grupo <CODE>SUBGRP</CODE>. O tal sub-grupo
é o documento onde nomes das salas, suas URLs e suas lotações são fornecidos.
<A HREF="#item_list_subgrp"><CODE>list_subgrp</CODE></A> é simplesmente uma interface para esse documento.
Parâmetro <CODE>SUBGRP</CODE> é uma string com URL de formato
<EM>'http://batepapo.uol.com.br/bp/excgi/salas_new.cgi?ID=idim_he.conf'</EM>
ou então simplesmente <EM>'idim_he.conf'</EM>. Os dois são equivalentes.
Quando você usa <A HREF="#item_list_subgrp"><CODE>list_subgrp</CODE></A> antes de <A HREF="#item_login"><CODE>login</CODE></A>, <CODE>SUBGRP</CODE> é salvo e
utilizado como <CODE>REF</CODE> de <A HREF="#item_login"><CODE>login</CODE></A> automaticamente. O método retorna
um array de hashes se tiver sucesso e <EM>()</EM> se houver falha. O array
retornado pode ser expandido com:
<PRE>
  my @room = $bot-&gt;list_subgrp ('idim_he.conf');
  foreach $room (@room) {
     print $room-&gt;{URL}, &quot;\n&quot;,
           $room-&gt;{Title}, &quot;\n&quot;,
           $room-&gt;{Load}, &quot;\n\n&quot;;
  }</PRE>
<P>onde <CODE>URL</CODE> é a URL da sala de bate-papo, <CODE>Title</CODE> é o título dela e
<CODE>Load</CODE> é o número de pessoas na sala
(0-40, -1 significa <EM>``sala lotada''</EM>).</P>
<P></P>
<DT><STRONG><A NAME="item_brief"><CODE>brief (ROOM)</CODE></A></STRONG><BR>
<DD>
``Espia'' na sala sem entrar nela. Retorna <EM>0</EM> se falha. Caso tiver sucesso,
<OL>
<LI>
guarda a lista com nomes de usuários para depois ser vista com <A HREF="#item_users"><CODE>users</CODE></A>
<P></P>
<LI>
passa o fragmento da conversa para rotina definida em <A HREF="#item_Listen_Handler"><CODE>Listen_Handler</CODE></A>
<P></P>
<LI>
retorna <EM>1</EM>
<P></P></OL>
<DT><STRONG><A NAME="item_login"><CODE>login (ROOM [, REF])</CODE></A></STRONG><BR>
<DD>
Efetua <EM>login</EM> na sala <CODE>ROOM</CODE> de bate-papo. Parâmetro <CODE>ROOM</CODE> consiste
de uma string de formato <CODE>&quot;http://batepapo4.uol.com.br:3999/&quot;</CODE>. Parâmetro
<CODE>REF</CODE>, opcional, é o <EM>Referer</EM>, o documento que continha o link para
<CODE>ROOM</CODE>. Se você omitir o <CODE>REF</CODE>, valor
<EM>'http://batepapo.uol.com.br/bp/excgi/salas_new.shl'</EM>
será usado automaticamente. Se você estiver usado <A HREF="#item_list_subgrp"><CODE>list_subgrp</CODE></A> antes
de <A HREF="#item_login"><CODE>login</CODE></A>, a URL de sub-grupo listado será usada como <CODE>REF</CODE>.
Leia mais sobre <A HREF="#item_list_subgrp"><CODE>list_subgrp</CODE></A>.
<P>Retorna <EM>0</EM> se houver falha e <EM>1</EM> se tiver sucesso. A ``falha'' mais provável
é que a sala esteja cheia.</P>
<P></P>
<DT><STRONG><A NAME="item_is_logged"><CODE>is_logged</CODE></A></STRONG><BR>
<DD>
Retorna <EM>1</EM> se o bot estiver atualmente numa sala de bate-papo e <EM>0</EM> caso contrário.
<P></P>
<DT><STRONG><A NAME="item_login_error"><CODE>login_error</CODE></A></STRONG><BR>
<DD>
Retorna o código do erro durante login:
<PRE>
  0     - sucesso
  1     - nickname já foi utilizado
  2     - sala está cheia
  undef - erro desconhecido (ver valor de $!)</PRE>
<P></P>
<DT><STRONG><A NAME="item_users"><CODE>users</CODE></A></STRONG><BR>
<DD>
Retorna array de nicknames de usuários atualmente presentes na sala
de bate-papo. Os dados são atualizados toda vez que você efetua <A HREF="#item_login"><CODE>login</CODE></A>
ou <A HREF="#item_send"><CODE>send</CODE></A>. Desculpe, não fui eu quem inventou isso... Retorna no mínimo
o próprio nickname (a sala não está vazia se <EM>você</EM> está lá <CODE>;)</CODE> ou <EM>()</EM>
no caso de falha.
<P></P>
<DT><STRONG><A NAME="item_send"><CODE>send ([MSG] [, ATTR])</CODE></A></STRONG><BR>
<DD>
Envia mensagem <CODE>MSG</CODE> para sala de bate-papo. Possui 4 sintaxes:
<OL>
<LI>
<PRE>
 $bot-&gt;send ('mensagem 1');</PRE>
<P>a mais simples, envia string <EM>'mensagem 1'</EM></P>
<LI>
<PRE>
 $bot-&gt;send ('mensagem 2', To =&gt; 'TODOS', Action =&gt; 15);</PRE>
<P>envia string <EM>'mensagem 2'</EM> com atributos <A HREF="#item_To"><CODE>To</CODE></A> e <A HREF="#item_Action"><CODE>Action</CODE></A> explicados abaixo</P>
<LI>
<PRE>
 $bot=&gt;send (Msg =&gt; 'mensagem 3', To =&gt; 'TODOS', Action =&gt; 15);</PRE>
<P>o mesmo de cima para <EM>'mensagem 3'</EM></P>
<LI>
<PRE>
 $bot-&gt;send ();</PRE>
<P>sintaxe mais obscura, não envia <STRONG>nada</STRONG>, apenas atualiza a lista que
pode ser obtida com método <A HREF="#item_users"><CODE>users</CODE></A>. De novo, não fui eu quem inventou!</P>
</OL>
<P>Agora, sobre atributos <CODE>ATTR</CODE>. São todos opcionais
(forma <CODE>Chave =&gt; 'Valor'</CODE>), aqui está a lista
com uma breve explicação:</P>
<DL>
<DT><STRONG><A NAME="item_Msg"><EM>Msg</EM></A></STRONG><BR>
<DD>
a mensagem em si, string (só pode ser usado com <EM>sintaxe 3</EM>, ignorado na <EM>sintaxe 2</EM>!)
<P></P>
<DT><STRONG><A NAME="item_Action"><EM>Action</EM></A></STRONG><BR>
<DD>
ação, valor inteiro. Ações possíveis:
<PRE>
  0  - fala para (default)
  1  - pergunta para
  2  - responde para
  3  - concorda com
  4  - discorda de
  5  - desculpa-se com
  6  - surpreende-se com
  7  - murmura para
  8  - sorri para
  9  - suspira por
  10 - flerta com
  11 - entusiasma-se com
  12 - ri de
  13 - dá um fora em
  14 - briga com
  15 - grita com
  16 - xinga</PRE>
<PRE>
  18 - IGNORAR mensagens de
  19 - só receber mensagens de
  20 - não IGNORAR mais</PRE>
<P></P>
<DT><STRONG><A NAME="item_To"><EM>To</EM></A></STRONG><BR>
<DD>
o nickname do receptor da ação <EM>Action</EM>, string. Valor default é <EM>'TODOS'</EM>.
<P><EM>Obs1</EM>: <STRONG>não necessariamente</STRONG> é alguém que esteja na sala. Isto é, você
pode fazer:</P>
<PRE>
  $bot-&gt;send ('bots da UOL, uní-vos!', To =&gt; 'bots renegados');</PRE>
<P><STRONG>desde que</STRONG> <EM>não</EM> seja uma mensagem reservada (<CODE>Reserved =&gt; 1</CODE>)!</P>
<P><EM>Obs2</EM>: independentemente do valor do <EM>To</EM>, todos os usuários da sala
irão ler a mensagem. Para mensagens privadas, use <EM>Reserved</EM>.</P>
<P></P>
<DT><STRONG><A NAME="item_Reserved"><EM>Reserved</EM></A></STRONG><BR>
<DD>
pode ser <EM>1</EM> ou <EM>0</EM>. Quando <EM>1</EM>, a mensagem é enviada reservadamente
para nickname <EM>To</EM>. Valor default é <EM>0</EM>.
<P></P>
<DT><STRONG><A NAME="item_Sound"><EM>Sound</EM></A></STRONG><BR>
<DD>
som a ser enviado, inteiro. Sons possíveis:
<PRE>
  0  - nenhum (default)
  14 - Ahn???
  15 - Bang!
  16 - Banjo
  17 - Dinossauro
  18 - Fiu-fiu
  19 - Ocupado
  20 - Oinc
  21 - Pigarro
  22 - Smack!
  23 - Susto
  24 - Telefone
  25 - Tôlôca
  26 - Tosse
  07 - Como é?
  08 - Não entendi</PRE>
<P></P>
<DT><STRONG><A NAME="item_Icon"><EM>Icon</EM></A></STRONG><BR>
<DD>
ícone a ser enviado, inteiro. Ícones possíveis:
<PRE>
  0  - nenhum (default)
  38 - Assustado
  27 - Bocejo
  23 - Careta
  30 - Dentuço
  18 - Desejo
  31 - Eca !
  32 - Gargalhada
  33 - Indeciso
  34 - Louco
  28 - Na praia
  35 - Ohhh !
  20 - OK!
  36 - Piscada
  37 - Raiva
  19 - Smack!
  21 - Sorriso
  26 - Zangado</PRE>
<P></P></DL>
<P>Retorna <EM>0</EM> se houver falha e <EM>1</EM> se tiver sucesso.</P>
<P><EM>Obs</EM>: <STRONG>aparentemente</STRONG> o servidor não aceita mensagens &gt; 200 bytes.</P>
<DT><STRONG><A NAME="item_scroll"><CODE>scroll (TIMEOUT)</CODE></A></STRONG><BR>
<DD>
<EM>Obs</EM>: Provavelmente a parte mais chatinha... Mas indispensável se você
quer comunicação <STRONG>bidirecional</STRONG>, isto é, o seu bot envia <STRONG>E</STRONG> recebe dados.
<P>O <A HREF="#item_scroll"><CODE>scroll</CODE></A> visa limpar buffers de entrada e enviar dados para sub-rotina
definida em <A HREF="#item_Listen_Handler"><CODE>Listen_Handler</CODE></A> (leia mais sobre argumentos de <A HREF="#item_new"><CODE>new</CODE></A>). Se o
<EM>listen_handler</EM> for omitido então os buffers serão limpos e a rotina
retornará sucesso (<EM>1</EM>). Só retorna <EM>0</EM> se houver quebra inesperada
de conexão.</P>
<P>O parâmetro <CODE>TIMEOUT</CODE> é o tempo que o <A HREF="#item_scroll"><CODE>scroll</CODE></A> deva esperar até
retornar caso o buffer esteja vazio, em segundos. Resumindo,
<A HREF="#item_scroll"><CODE>scroll()</CODE></A> ou <A HREF="#item_scroll"><CODE>scroll(0)</CODE></A> retorna imediatamente (timeout 0).
<A HREF="#item_scroll"><CODE>scroll(10)</CODE></A> aguarda 10 segundos pelo dado. <A HREF="#item_scroll"><CODE>scroll(-1)</CODE></A> pausa o programa
até que um dado apareça no buffer.</P>
<P>O <A HREF="#item_scroll"><CODE>scroll</CODE></A> é chamado automaticamente pelos métodos <A HREF="#item_login"><CODE>login</CODE></A>, <A HREF="#item_logout"><CODE>logout</CODE></A>
e <A HREF="#item_send"><CODE>send</CODE></A>, portando, não há como o seu <A HREF="#item_Listen_Handler"><CODE>Listen_Handler</CODE></A> perder algum dado.
Porém, se você quiser mais controle, rode um <A HREF="#item_scroll"><CODE>scroll</CODE></A> com <EM>timeout</EM>
razoável sempre que estiver esperando alguma resposta do servidor.</P>
<P><EM>Obs</EM>: Alguém aí pensou <EM>fork</EM>? Acredite em mim, <STRONG>não</STRONG> vale a pena!
Eu <EM>comecei</EM> a desenvolver bot bifurcado, com um <EM>child</EM> para entrada
(rodando só <CODE>while ($bot-&gt;scroll(-1)) { ... }</CODE>) e outro para saída
(rodando <A HREF="#item_send"><CODE>$bot-&gt;send(...)</CODE></A>). A sincronização dos dois virou um inferno e o
<EM>ActivePerl</EM>, meu plataforma principal, não era muito amigo do <EM>fork</EM>.
Se você pensar um pouco, verá que o problema em questão é totalmente
linear, nunca duas ações são feitas em paralelo. Agora, se você estiver
usando plataforma <EM>UNIX</EM> e não quiser se preocupar onde pôr o <A HREF="#item_scroll"><CODE>scroll</CODE></A>,
coloque antes do <A HREF="#item_login"><CODE>login</CODE></A>:</P>
<PRE>
  $SIG{ALRM} = sub { $bot-&gt;scroll; alarm 1 };
  alarm 1;</PRE>
<P>Se você está vendo essa técnica pela 1-a vez, conforme-se com o que já tem.</P>
<P></P>
<DT><STRONG><A NAME="item_logout"><CODE>logout</CODE></A></STRONG><BR>
<DD>
Efetua <EM>logout</EM> da sala de bate-papo. Retorna <EM>0</EM> se houver falha e
<EM>1</EM> se tiver sucesso.
<P></P></DL>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>Testei rigorosamente esse módulo, afinal por que a idéia é que um <STRONG>bot</STRONG>
rode 24 horas por dia 7 dias por semana <EM>sem manutenção</EM>.</P>
<P>Porém deixei de implementar coisas que me pareceram inúteis, tais como:</P>
<UL>
<LI>
incompatibilidade com <CODE>Win32</CODE>
<P>Calma, calma, você <STRONG>pode</STRONG> executar o <CODE>UOLbot</CODE> numa plataforma <CODE>Win32</CODE>.
Porém, vi que <EM>as vezes</EM> há falhas muito estranhas no <CODE>LWP</CODE>. Uma hora
tá tudo OK, outra hora não funciona. Eu fiz testes com
<CODE>ActivePerl 5.6.1 Build 630</CODE>, utilizando <CODE>Windows 98</CODE> e <CODE>Windows 98 SE</CODE>.
O primeiro não apresentou falhas, o segundo apresentou raramente. Mas
na minha opinião pessoal, eu não confiaria em <STRONG>nada</STRONG> feito pela <EM>Micro$oft</EM>.
Não confiaria nem nos softwares livres rodando em cima de produtos da
<EM>Micro$oft</EM>. Portando, aqui vai uma dica que vai te livrar de muitos problemas:
<STRONG>use Linux</STRONG>.</P>
<P></P>
<LI>
tolerância à falhas humanas
<P>O mínimo esperado do usuário é que passe parâmetros corretos; não passe
string onde um número é esperado e nem passe expressão regular onde era
para pôr referência ao código...</P>
<P>Ainda assim, fiz o necessário para proteger o usuário contra dar um
<A HREF="#item_logout"><CODE>logout</CODE></A> antes que seja feito um <A HREF="#item_login"><CODE>login</CODE></A>, portanto não se desanime.</P>
<P></P>
<LI>
``caretas'' na frente do nick
<P>Precisa ser assinante para usar tal artefato inútil. Duvido que um bot assine UOL!</P>
<P></P>
<LI>
utilizar um proxy HTTP
<P>Grande maioria dos proxies públicos (os normalmente utilizados para anonimizar
acessos) não deixa conectar nas portas não-HTTP. <STRONG>Nenhuma</STRONG> das salas de bate-papo
reside na porta HTTP (80). E então?</P>
<P></P></UL>
<P>Outra coisa... Olha a data desse arquivo. <STRONG>Nessa</STRONG> data <CODE>UOLbot</CODE> estava
funcionando, pode ter certeza. Se não está agora, é porque pessoal da UOL
alterou o sistema de webchat. Sinto muitíssimo... O que você tem a fazer é
ou procurar versão mais atual de <CODE>UOLbot</CODE> ou adaptar o código desse aqui.
Não deve ser difícil, fiz código o mais claro e limpo que pude, até comentei
tudo (ôôô)!</P>
<P>O mesmo se aplica a qualquer valor ou tabela citados aqui. A UOL muda
constantemente o seu sistema de webchat, fazer o quê...</P>
<P>
<HR>
<H1><A NAME="referências">REFERÊNCIAS</A></H1>
<UL>
<LI>
<EM>LWP</EM> - Library for WWW access in Perl
<P></P></UL>
<P>Vários exemplos distribuídos junto com o módulo:</P>
<DL>
<DT><STRONG><A NAME="item_simples%2Epl"><EM>simples.pl</EM></A></STRONG><BR>
<DD>
a aplicação mais simples; listar um sub-grupo, entrar na sala #15,
repetir mensagem 5 vezes, sair.
<P></P>
<DT><STRONG><A NAME="item_crawler%2Epl"><EM>crawler.pl</EM></A></STRONG><BR>
<DD>
bot de propaganda; entra em todas as salas nos sub-grupos especificados
e deixa uma mensagem.
<P></P>
<DT><STRONG><A NAME="item_list%2Epl"><EM>list.pl</EM></A></STRONG><BR>
<DD>
busca em sub-grupos especificados e retorna lista de URLs de salas
de bate-papo e seus respectivos títulos.
<P></P></DL>
<P>
<HR>
<H1><A NAME="versão">VERSÃO</A></H1>
<P>1.1</P>
<P>
<HR>
<H1><A NAME="histórico">HISTÓRICO</A></H1>
<UL>
<LI>
<STRONG>1.0</STRONG> <EM>(25/Jan/2002)</EM> - primeira versão funcional
<P></P>
<LI>
<STRONG>1.1</STRONG> <EM>(09/Fev/2002)</EM> - utilizado o <CODE>Carp::croak</CODE> para erros de usuário e
adicionado o método <A HREF="#item_brief"><CODE>brief</CODE></A>. Correções menores na documentação.
<P></P></UL>
<P>
<HR>
<H1><A NAME="copyright">COPYRIGHT</A></H1>
<PRE>
  Copyright (C) por Stanislaw Y. Pusep, Janeiro de 2002</PRE>
<OL>
<LI>
A utilização desse <EM>módulo</EM>, assim como distribuição do <EM>módulo</EM> e/ou
suas <EM>versões</EM> (alterações feitas no <EM>módulo</EM> por terceiros) somente
deve ser feita com autorização explicita proveniente do <EM>autor</EM>.
<P></P>
<LI>
Aqueles que tem cópia autorizada do <EM>módulo</EM> tem o direito de gerar
<EM>versões</EM> (alterar o <EM>módulo</EM> conforme for conveniente a eles). <STRONG><A HREF="#item_%28%2A%29"><CODE>(*)</CODE></A></STRONG>
<P></P>
<LI>
Qualquer programa feito com utilização desse <EM>módulo</EM> pode ser usado
para quaisquer fins (inclusive lucrativos). <STRONG><A HREF="#item_%28%2A%29"><CODE>(*)</CODE></A></STRONG>
<P></P></OL>
<DL>
<DT><STRONG><A NAME="item_%28%2A%29"><STRONG><CODE>(*)</CODE></STRONG></A></STRONG><BR>
<DD>
Desde que não haja infração do <CODE>item 1</CODE>.
<P></P></DL>
<P>
<HR>
<H1><A NAME="autor">AUTOR</A></H1>
<P>Nome: Stanislaw Y. Pusep</P>
<P>E-Mail: <A HREF="mailto:stanis@linuxmail.org">stanis@linuxmail.org</A></P>
<P>Homepage: <A HREF="http://sysdlabs.hypermart.net/">http://sysdlabs.hypermart.net/</A></P>

</BODY>

</HTML>
